"""
func : mock 根据数据库数据批量生成服务器上的 wiremock工具__files和mappings文件
date : 2021-09-15
author : qi.wang02@msxf.com
"""

# 3.数据清洗，过滤.保存到本地然后就一起上传 ---ing
# 6.打印成功mock数量及其他关键日志 ---todo
import paramiko
import os
from stat import S_ISDIR
import shutil

# ssh连接配置
mock_ip = '10.99.67.21'
username = 'root'
passwd = 'msxf@testvm-2019'


class SshConnectError(Exception):
    pass


class ConnectSsh(object):
    def __init__(self, host, username, passwd, port=22):
        self.host = host
        self.username = username
        self.passwd = passwd
        self.port = port
        self.ssh = self.__ssh()
        self.sftp = self.__sftp()
        self.file_count = 0
        print("1.ssh init finish~")

    def __ssh(self):
        """
        创建ssh client连接 并返回
        :return:
        """
        client = paramiko.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            client.connect(self.host, self.port, self.username, self.passwd)
        except:
            raise SshConnectError(f'''SSh Connect Host Error: [{self.host}]''')
        return client

    def __sftp(self):
        """
        返回sftp通道连接对象
        :return:
        """
        trans = self.ssh.get_transport()  # ssh 连接 建立通道
        sftp = paramiko.SFTPClient.from_transport(trans)  # 创建一个已连通的SFTP客户端通道
        return sftp

    def execCommand(self, cmd, timeout=2000):
        _, stdout, stderr = self.ssh.exec_command(cmd, timeout=timeout)
        try:
            channel = stdout.channel
            exit_code = channel.recv_exit_status()
            stdout = stdout.read().strip()
            stderr = stderr.read().strip()
            print(f"stdout:[{stdout}] \nstderr:[{stderr}]")
            # return {"status": 1, "stdout": stdout, "stderr": stderr, 'exit_code': exit_code}
        except:
            print(f"stdout:[{stdout}] \nstderr:[{stderr}]")
            # return {"status": 0, "stdout": stdout, "stderr": stderr, 'exit_code': 127}

    def upload_dir(self, local_dir, remote_dir, move_state=False):
        """
        上传本地目录下所有文件 到 远程主机对应的目录下
        :param local_dir: 本地文件夹名字
        :param remote_dir: 远程文件夹名字
        :param move_state: 是否删除本地文件
        :return:
        """
        if os.path.isdir(local_dir):
            # 文件夹，不能直接下载，需要继续循环
            self.__check_sftp_dir(remote_dir)
            for remote_file_name in os.listdir(local_dir):
                self.file_count += 1
                sub_local = os.path.join(local_dir, remote_file_name)
                sub_local = sub_local.replace('\\', '/')
                sub_remote = os.path.join(remote_dir, remote_file_name)
                sub_remote = sub_remote.replace('\\', '/')
                # print(sub_local, sub_remote)
                self.upload_dir(sub_local, sub_remote)
        else:
            # print('开始上传文件：' + local_dir)
            # print('开始上传文件：' + remote_dir)
            self.sftp.put(local_dir, remote_dir)
        if move_state:
            shutil.rmtree(local_dir)

    def isdir(self, path):
        try:
            return S_ISDIR(self.sftp.stat(path).st_mode)
        except IOError:
            return False

    def __check_local_dir(local_dir_name):
        """
        本地文件夹是否存在，不存在则创建
        """
        if not os.path.exists(local_dir_name):
            os.makedirs(local_dir_name)

    def __check_sftp_dir(self, remote_dir_name):
        """
        sftp文件夹是否存在，不存在则创建
        """
        try:
            self.sftp.stat(remote_dir_name)
        except IOError as e:
            self.sftp.mkdir(remote_dir_name)

    def download_dir(self, remote_dir_name, local_dir_name):
        try:
            self.sftp.stat(remote_dir_name)
        except Exception:
            raise BaseException({"error": "sftp路径不存在"})
        remote_file = self.sftp.stat(remote_dir_name)
        if S_ISDIR(remote_file.st_mode):
            # 文件夹，不能直接下载，需要继续循环
            self.__check_local_dir(local_dir_name)
            print('开始下载文件夹：' + remote_dir_name)
            for remote_file_name in self.sftp.listdir(remote_dir_name):
                sub_remote = os.path.join(remote_dir_name, remote_file_name)
                sub_remote = sub_remote.replace('\\', '/')
                sub_local = os.path.join(local_dir_name, remote_file_name)
                sub_local = sub_local.replace('\\', '/')
                self.download_dir(sub_remote, sub_local)
        else:
            # print('开始下载文件：' + remote_dir_name)
            self.sftp.get(remote_dir_name, local_dir_name)

    def close(self):
        self.ssh.close()


# coo = ConnectSsh(mock_ip, username, passwd)
# coo.execCommand("pwd")
# coo.upload_dir(r'D:\mock_tools\template', '/home/test_upload')
# print(f"upload files [{coo.file_count}]个,finished")
# coo.close()

mySshConnect = ConnectSsh(mock_ip, username, passwd)
